## TDD 공부 Repository

테스트 주도 개발 시작하기 책으로 TDD 수터디중
관련 내용 정리 진행

### 준비 
TDD를 위한 다양한 도구가 존재하는데 자바에서는 주로 Junit을 사용한다. (Junit5)
pom파일에 junit 의존성 추가
```
...
<!-- junit-jupiter 의존을 test 범위로 추가한다. -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.5.0</version>
    <scope>test</scope>
</dependency>
...
<!-- 2.22.0부터 junit5지원 -->
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.1</version>
</plugin>
...
```

### TDD란?
- 테스트 부터 시작. 그 다음에 구현
- 테스트를 먼저한다 = 기능이 올바르게 동작하는지 검증하는 테스트 코드를 작성한다는 것을 의미
- 이 테스트를 통과 시키기 위해 개발을 진행한다.

-> 테스트를 먼저 작성하고 테스트에 실패하면 테스트를 통과 시킬만큼 코드를 추가하는 과정을 반복하면서 점진적으로 기능을 완성해 나감


**테스트 작성** 
- 첫번째 테스트를 선택할 때에는 가장 쉽거나 가장 예외적인 상황을 선택해야함
- 테스트 -> 코딩 -> 리펙토링 -> 테스트 반복.. (레드-그린-리펙터)
- TDD는 기능을 검증하는 테스트를 먼저 작성. 통과 못하면 통과 만큼만 코드 작성. 테스트 통과 뒤 리펙토링 반복 기능완성


&nbsp;
----
### 테스트 코드 작성 순서

- 쉬운 경우에서 어려운 경우로 진행 (복잡한거부터 하지마세요)
- 예외적인 경우에서 정상인 경우로 진행 

**구현하기 쉬운 테스트부터 시작하기**
- 가장 구현하기 쉬운 경우부터 시작하면 빠르게 통과시킬 수 있다.
    - 보통 수분에서 십여 분 이내에 구현을 완료해서 통과시킬 수 있을 만큼 쉬운 것 선택
    - 두가지 모두 그냥 해당 값을 리턴
        - 모든 조건을 충족하는 경우
        - 모든 조건을 충족하지 않는 경우

**예외 상황 먼저 테스트해야하는 이유**
- 중간 예외 처리 시 조건문 중복 추가 -> 코드 복잡 버그 가능성 높임
- 초반 예외 테스트 시 이런 가능성 줄어들음

&nbsp;

### 구현 단계
1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화


**조언**
- 당연한 말이지만 구현을 시도했는데 잘 안되면 한발 물러서서 다시하세요
- 테스트를 통과한 뒤에는 리팩토링을 진행하세요
- 일단 동작하는 코드를 만드는 능력이 중요합니다.
- TDD 시작할 때 테스트할 목록을 미리 정리하면 좋다.
- 테스트 과정에서 새로운 테스트 사례 발견 시 그 사례를 목록에 추가 
- 테스트 목록을 적었다고 테스트를 한번에 다 작성하면 안됨
  - 하나의 테스트 코드를 만들고 이를 통과시키고 리펙토링하고 다음 테스트 코드 통과 리펙토링하는 짧은 리듬 반복
- 범위가 큰 리팩토링 진행 하기 전에는 코드 커밋 잊지 마세요
- 시작이 안될때는 단언부터 고민하세요
  - assertEquals(기대일, 만료일);
- TDD 진행 시 어떻게 해야할 지 생각이 나지 않거나 잘못한거 같을 떄 과감하게 코드를 지우고 다시 시작하세요
  - 명싱 쉬운테스트부터, 예외테스트부터, 완급조절

&nbsp;


### 04. 기능 명세 설계
- 설계는 기능 명세로부터 시작한다.
- 기능 명세를 구체화 하는 동안 입력과 결과를 도출하고 이렇게 도출한 기능 명세를 코드에 반영한다.
- 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파람, 리턴 타입등이 결정된다. 
- -> 이런 과정이 곧 설계

- 테스트 만드려면 ? 
  - 테스트할 기능 실행
    - 클래스, 메서드, 함수이름
    - 파라미터
  - 결과를 검증
    - 리턴 값

- 모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영
  - -> 테스트코드는 예를 이용한 구체적인 명세가 됨
- 최대한 예외적, 복잡한 상황에 해당하는 구체적인 예르 끄집어내야함
  - 담당자와 대화! (하지않는다면 원하는 결과를 얻을 수 없을 것)


### 05. Junit5 기초
- assertEquals() 메서드
  - 첫번째인자 : 기대값 / 두번째인자 : 검사하려는 값

#### 테스트 라이프 사이클
- Junit은 각 테스트마다 다음 순서로 코드 실행
1. 테스트 메서드를 포함한 객체 생성
2. (존재시) @BeforeEach 애너테이션 붙은 메서드 실행
   - @BeforeEach //private이면 안됨. 테스트 실행하는데 필요한 준비 작업시 사용
3. @Test 애너테이션 붙은 메서드 실행
4. (존재시) @AfterEach 애너테이션 붙은 메서드 실행
  - private이면 안됨. 테스트 실행 후 정리한 것이 있을 때 사용

- @BeforeAll
  - 한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야할 때
  - 정적 메서드에 붙임
- @AfterAll
  - 클래스의 모든 테스트 메서드를 실행한 뒤에 실행
  - 정적 메서드에 적용

#### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기
- 각 테스트 메서드는 서로 독립적으로 동작해야함
- 한 테스트의 메서드의 결과에 따라 다른 테스트의 메서드의 실행 결과가 달라지면 안됨
- 테스트 메서드가 서로 필드를 공유한다거나 실행 순서를 가정하고 테스트 하지 말 것

- @DisplayName
- @Disabled
  - 특정 테스트를 실행하고 싶지 않을 때
  - 아직 테스트 코드가 완성되지 않았거나 잠시동안 테스트를 실행하지 말아야할 때 사용

  
#### 모든 테스트 실행하기
- 개발 과정에서는 특정 테스트 클래스나 메서드만 실행
- 운영 배포 전에 모든 테스트 실행해서 깨지는게 없는지 확인
  - mvn test (래퍼 사용시 mvnw test)
  - gradle test (래퍼 사용시 gradlew test)
- maven life cycle에선 package에서도 실행


### 6. 테스트 코드의 구성
- 상황 찾기
  - 다양한 예외 상황을 찾아내고 이를 코드에 반영해야 기능이 비정상적으로 동작하는 것을 막을 수 있다.
- 테스트 코드의 구성요소
  - 상황(given)
  - 실행(when)
  - 결과(then)
- 실행 결과를 확인하는 쉬운 방법 : 리턴 값을 사용
- 상황이 테스트 대상으로 국한된 것은 아님. 외부 요인도 잇음
- 테스트 코드 안에 필요한 것이 다있음 장점
  - 테스트 내용을 이해하기 위해 많은 파일을 볼 필요가 없다.
- 테스트 대상이 아닌 외부에서 확인이 필요할 때도 있다.
  - 처리 결과 지정 경로 파일 생성 기능
  - -> 실행 결과 검증하려면 해당 경로에 파일이 원하는 대로 만들어졌는지 확인 
- 외부 상태가 테스트 결과에 영향을 주지 않게 하기 
  - 테스트 코드는 한번만 실행하고 끝이 아님. 계속 지속 반복 테스트 문제 없는지 검증
  - -> 언제 실행해도 항상 정상 동작이 중요
  - 테스트 실행전에 외부를 원하는 상태로 만들거나 테스트 실행 후 외부 상태를 원래대로 돌려놓아야한다. ex)롤백
- 테스트는 모든 상황이 고려되어야함
  - ex) 금융 회사에서 제공하는 REST API 사용시 자동이체 등록 기능에 대한 테스트 
    1. REST API 응답 결과가 유효한 계좌 번호인 상황
    2. 유효하지 않은 계좌 번호인 상황
    3. 서버에 연결할 수 없는 상황
    4. 서버에서 응답을 5초 이내에 받지 못하는 상황
- -> 테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재.
- 테스트 대상의 상황과 결과에 외부 요인이 관여하는 경우 대역을 사용하면 테스트가 쉬워짐
  - 대역 : 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현. 이를 통해 외부 상황, 결과 대체 가능


### 7. 대역 
- 테스트 진행 시 외부 요인이 필요한 시점
  - 테스트 대상에서 파일 시스템을 사용
  - DB로부터 데이터를 조회하거나 데이터를 추가
  - 테스트 대상에서 외부의 HTTP 서버와 통신 

- 테스트 대상에서 의존하는 요인 때문에 테스트가 어려울 때는 대역을 써서 테스트를 진행
- **대역의 종류**  ****
  - 스텁(Stub)
    - 구현을 단순한 것으로 대체한다.
    - 테스트에 맞게 단순히 원하는 동작을 수행한다.
    - ex) StubCardNumberValidator가 스텁 대역에 해당
  - 가짜(Fake)
    - 제품에는 적합하지 않지만 실제 동작하는 구현을 제공한다.
    - DB 대신에 메모리를 이용해서 구현하는 등
    - ex) MemoryAutoDebitInfoRepository가 가짜 대역에 해당
  - 스파이(Spy)
    - 호출된 내역을 기록한다.
    - 기록한 내용은 테스트 결과를 검증할 떄 사용한다.
    - 스텁이기도 하다.
  - 모의 객체(Mock)
    - 기대한 대로 상호작용 하는지 행위를 검증
    - 기대한 대로 동작하지 않으면 익셉션을 발생할 수 있다.
    - 모의객체는 스텁이자 스파이일 수도 있다.
- 구현하기 전에 모든 기능을 설계 불가능 -> 개발진행시 요구사항 계쏙 바뀔수도 있어서

#### 상황과 결과 확인을 위한 협업 대상(의존) 도출과 대역 사용
- 한 테스트는 특정한 상황에서 기능을 실행하고 그 결과를 확인
- 실제 구현을 이용하면 상황을 만들기 어려울 때가 많음
- 제어가 힘든 외부 상황 존재시 다음 방법으로 의존 도출 및 대역으로 이용
  - 제어하기 힘든 외부 상황을 별도 타입으로 분리 ex) StubCardValidator
  - 테스트 코드는 별도로 분리한 타입의 대역을 생성
  - 생성한 대역을 테스트 대상의 생성자 등을 이용해서 전달
  - 대역을 이용해서 상황 구성
- 당장 구현하는데 시간이 오래 걸리는 로직도 분리하기에 좋은 후보.

#### 대역과 개발 속도
- 대역은 의존하는 대상을 구현하지 않아도 테스트 대상을 완성할 수 있게 만들어 주고 대기시간 줄여줘 개발 속도 올림
  - 대역 사용시 실제 구현 없어도 다양한 상황에서 테스트 가능
  - 대역을 사용하면 실제 구현이 없어도 실행 결과 확인 가능

#### 모의 객체를 과하게 사용하지 않기!
- 모의 객체는 스텁과 스파이를 지원하므로 대역으로 모의객체 많이 사용
- 하지만 모의객체 과하게 사용하면 오히려 테스트 코드가 복잡해지는 경우도 있음.
- dao나 리포지토리 같이 저장소에 대한 대역은 모의 객체를 사용하는 것 보다 메모리를 이용한 가짜 구현을 사용하는 것이 테스트 코드 관리에 유리하다.
  - 첨엔 더 걸릴 수 있으나 일단 가짜 대역을 구현하면 모의객체를 사용할때 보다 테스트 코드 간결 관리 쉬움


---

### 부록C. Mockito 기초 사용법
- Mockito : 모의 객체 생성, 검증, 스텁을 지원하는 fw
- 사용하려면 mokcito-core 모듈 추가

#### 모의 객체 생성
- Mocito.mock()

#### 스텁 설정
- 모의객체를 생성한 뒤에 BDDMockito 클래스를 이용해서 모의 객체에 스텁을 구성할 수 있다.
- BDDMockito.given() 메서드 이용
  - 스텁을 정의할 모의객체의 메서드 호출을 전달
- given()에 이어 willReturn() 메서드는 스텁을 정의한 메서드가 리턴할 값을 지정
- ex)
  - (1) 모의 객체 생성 : GameNumGen genMock = mock(GameNumGen.class)
  - (2) 스텁 설정 : given(genMock.generate(GameLevel.EASY)).willReturn("123");
  - (3) 스텁 설정에 매칭되는 메서드 실행 : String num = genMock.generate(GameLevel.EASY)
- 지정한 값 리턴하는 대신 익셉션 발생하게 설정 willTrhow(IllegalArgumentException.class)

#### 인자 매칭 처리
- Mockito는 일치하는 스텁 설정이 없을 경우 리턴 타입의 기본 값을 리턴한다.
  - ex) int 0, boolean false 기본 데이터 타입이 아닌 String/List와 같은 참조 타입이면 null
- Mockito.ArgumentMatchers클래스 사용시 정확하게 일치하는값 대신 임의의 값 일치하도록 설정 가능
  - any(), anyInt, anyShort(), anyLong, ... anyList, any(), matches(String), matches(Pattern), eq(값)
- 스텁을 설정할 메서드의 인자가 두개 이상인 경우 주의
- 임의의 값과 일치하는 인자와 정확하게 일치하는 인자를 함께 사용하고 싶다면 ArgumentMatchers.eq()


#### 행위 검증
- 모의 객체의 역할 중 하나는 실제로 모의 객체가 불렸는지 검증하는 것
- BDDMockito.then() : 메서드 호출 여부를 검증할 모의 객체를 전달 받는다.
- should() : 모의 객체의 메서드가 불려야 한다는 것을 설정하고 뒤에 실제 불려야할 메서드 지정
- ex) then(genMock).should().generate(GameLevel.EASY);
- 정확한 값이 아닌 메서드가 불렸는지 여부가 중요하면 any, anyInt...
  - ex) then(genMock).should().generate(any());
- 정확하게 한번만 호출된 것 검증
  - ex) then(genMock).should(only()).generate(any());
- 메서드 호출 횟수 검증 위해 Mockito 클래스가 제공하는 메서드
  - only() : 한번만 호출
  - times(int) : 지정 횟수만큼 호출
  - never() : 호출x
  - atLeast(int) : 적어도 지정한 횟수만큼
  - atLeatOnce : atLeast(1)
  - atMost(int) : 최대 지정한 횟수만큼

#### 인자 캡처
  - 모의 객체 호출 할 때 사용한 인자 검증 해야할 떄 있음
  - Mockito의 ArgumentCaptor : 메서드 호출 여부를 검증하는 과정에서 실제 호출할 때 전달한 인자 보관
    ```
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class)
    then(mockEmailNotifiler).sholud().sendRegisterEmail(captor.capture());
    String relEmail = captor.getValue();
    assertEquals("email@email.com", realEmail);
    ```

#### Junit5 확장 설정
- Mockito의 Junit5 확장 기능을 사용하면 애노테이션을 이용해서 모의 객체 생성 가능
- mockito-junit-jupitor -> Mocito Extension 사용 가능
- @Mock : 붙인 필드에 대해 자동으로 모의 객체 생성해줌
  ```
  @ExtendWith(MocktoExtension.class)
  public class Junit5ExtensionTest() {
  @Mock
  private GameNumGen genMock;
  ```
  

### 8. 테스트 가능한 설계

#### 테스트가 어려운 코드
- 하드 코딩된 경로
- 의존 객체를 직접 생성
- 정적 메서드 사용
- 실행 시점에 따라 달라지는 결과
- 역할이 섞여있는 코드
- 메서드 중간에 소켓 통신 코드가 포함
- 콘솔에서 입력받거나 결과를 콘솔에 출력한다.
- 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다.
- 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다.
- -> 의존하는 코드를 교체할 수 있는 수단이 없기 때문에 어렵다.

#### 테스트가 가능한 설계
상황에 따라 알맞은 방법을 적용하며 의존 코드를 교체할 수 있게 만들어야 한다.

- 하드 코딩된 상수를 생성자나 메서드 파라미터, 세터로 받기 
- 의존 대상을 주입받기 (교체가 가능하도록 use 생성자 or setter)
- 테스트하고 싶은 코드를 분리하기
- 시간이나 임의의 값 생성 기능 분리하기
  - 시간이나 임의의 값 사용 시 테스트 시점에 따라 테스트 결과가 달라질 수 있다.
- 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기 (=외부 라이브러리와 연동하기 위한 타입을 따로 만든다.)


### 테스트 범위와 종류

- 테스트의 범위는 테스트의 목적과 수행하는 사람에 따라 달라진다.
- 테스트 범위
  - 단위 테스트 (서비스,모델)
  - 통합 테스트 (톰캣-DB)
  - 기능 테스트 (브라우저-톰캣-DB)

#### 기능 테스트와 E2E테스트
- 기능 테스트
  - **사용자 입장**에서 시스템이 제공하는 기능이 올바르게 동작하는지 확인
  - 이 테스트 수행하려면 시스템을 구동하고 사용하는데 필요한 모든 구성 요소가 필요
  - ex) 회원가입 기능 -> 웹서버, 데이터베이스, 웹 브라우저
  - ex) 회원 가입 문자 발송기능까지 -> 외부 문자 발송 서비스까지 테스트
  - E2E(end to end)테스트로 불림
    - 사용자가 직접 사용하는 웹 브라우저나 모바일 앱부터 시작해서 데이터베이스나 외부 서비스에 이르기까지 모든 구성 요소를 하나로 엮어서 진행
    - 끝(브라우저)에서 끝(디비)까지 올바른지 검사
  - QA조직에서 하는 테스트

- 통합 테스트
  - 시스템의 각 구성요소가 올바르게 연동 되는지 확인
  - 소프트웨어의 코드를 직접 테스트
  - ex) 모바일앱을 통한 가입기능 테스트 / 통합테스트는 서버의 회원 가입 코드를 직접 테스트 -> 회원 가입 서비스 클래스에 대한 테스트가 통합테스트 예시
    - 스프링 프레임워크나 마이바티스 설정이 올바른지, SQL 쿼리가 맞는지, DB 트랜잭션이 잘 동작하는지 등
  - 일반적인 웹 어플리케이션은 fw, lib, db, 구현코드가 주요 통합테스트 대상
  - 단위 테스트에 비해 실행 시간도 길지만 필요. 각 구성요소가 올바르게 연동 되는 것을 확인해야하는데 이를 자동화 하기 좋은 수단이 통합테스트

- 단위 테스트
  - 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인
  - 한 클래스나 한 메서드와 같은 작은 범위를 테스트
  - 일부 의존 대상은 스텁이나 모의 객체 등을 이용해서 대역으로 대체
  - 단위 테스트 코드를 많이 만들어야한다. 
  - 테스트 코드를 빼면 준비할 게 없다.
  - 통합 테스트나 기능 테스트로 상황 준비나 결과 확인이 어려운 경우 단위 테스트와 대역을 조합해서 상황을 만들고 결과를 확인


#### 테스트 범위에 따른 테스트 코드 개수와 시간
- 테스트 자동화 하는 시도가 증가
  - 그만큼 고품질의 소프트웨어를 더 빠르게 출시할 수 있기 떄문.
  - 테스트를 자동화 한다는 것 -> 코드로 작성한 테스트를 실행한다는 것
- 기능 테스트는 환경을 갖춰야하기 떄문에 정상, 특수 몇가지만 테스트 범위로 잡는다.
- 기능 테스트나 통합테스트에서 모든 예외 상황을 테스트하면 단위 테스트는 줄어든다.
- 가능한 단위 테스트에서 다양한 상황을 다루고 통합, 기능 테스트는 주요 상황에 초점을 맞춰라 (더빠르니)

#### 외부 연동 필요한 테스트 예시
- 모든 외부 연동 대상을 통합테스트에서 다룰 수 없지만 일부 대상은 어느정도 수준에서 제어 가능
- ex) DB, HTTP연동
- WireMock을 사용하면 서버 API를 스텁으로 대체할 수 있다.
- 스프링부트의 내장 서버를 이용한 API 테스트
  - 테스트에서 웹 환경을 구동할 수 있는 기능을 제공
  - 테스트는 이 기능을 사용해서 내장 서버를 구동하고 스프링 웹 어플리케이션을 실행
  - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)


### 10. 테스트 코드와 유지보수
- 빠른 서비스 출시 위해 CI/CD. 자동화 테스트는 CI/CD의 필수 요건 중 하나.
- TDD 통한 테스트 코드는 버그 배포 방지 및 품질 저하 방지
- 테스트 코드는 그 자체로 코드. 제품코드와 동일하게 유지 보수 대상이 됨.
- 테스트 방치시 품질 낮아짐
- 악순환 발생 막기 위해 테스트 코드 자체의 유지보수성이 좋아야함 

#### 테스트 코드를 만드는 데 주의 사항
1. 변수나 필드를 사용해서 기댓값 표현 하지 않기 
  - 변수와 필드를 오가며 테스트 코드를 이해해야한다. 안좋다.
  - 변수와 필드 대신 값 자체를 사용하라 -> 가독성이 좋아져서 테스트 코드 파악이 쉽다.
2. 2개 이상 을 검증하지 않기
   - 한 테스트에서 검증하는 내용이 두개 이상이면 테스트 결과를 확인할 때 집중도가 떨어진다.
   - 대상을 별도로 분리해서 테스트의 집중도를 높이라
3. 정확하게 일치하는 값으로 모의 객체 설정하지 않기
  - 모의 객체는 가능한 범용적인 값을 사용해서 기술. 한정된 값에 일치하도록 모의 객체 사용 시 약간의 코드 수정만으로 테스트 실패 가능성
  - pw라는 특정한 값보다 Mociko.anyString()과 같은 범용적인 값을 써라
4. 과도하게 구현 검증하지 않기
   - 테스트의 내부 구현을 검증해버림. 나쁜것은 아니지만 단점이 구현을 조금만 변경해도 테스트가 꺠질 수 있다.
   - 내부 구현은 언제든 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 **실행 결과**를 검증해야 한다.
   - 어쩔 수 없이 기능 정상 동작 수단 검증법이 구현 검증밖에 없다면 일단 모의 객체 사용해서 테스트 코드 작성하지만 그 뒤 리펙토링을 해서 구현이 아닌 결과를 검증할 수 있도록 수정
5. 셋업을 이용해서 중복된 상황을 설정하지 않기
   - 테스트 코드에서 동일한 상황이 필요할 때가 있다. @BeforeEach 코드가 준다는 장점이 있지만 그게 다좋지는 않다.
   - 테스트 메서드 자체에 직접 상황을 설명하는게 코드는 길어지지만 더 스스로 잘 설명 + 이해 및 유지보수에 도움이 된다.
6. 통합테스트에서 데이터 공유 주의하기
   - 모든 테스트가 다른값을 사용하면 안 되는 데이터는 동일한 데이터를 공유해도 된다. (코드값)
   - 특정 메서드만 의미 있는 데이터는 모두가 공유할 필요 없다. (중복 ID 검사를 위한 회원 데이터)
7. 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
   - 테스트 메서드에서 직접 상황을 구성하면서 코드 중복을 없애는 방법 
8. 실행 환경이 다르다고 실패하지 않기
   - 로컬에서는 하는데 빌드에서는 실패거나
   - 윈도우에서는 성공하는데 맥에서는 실패하는거나
   - 하지만 간혹 특정 OS환경에서만 실행해야하는 테스트가 있다.
     - Junit5 @EnabledOnOs 에너테이션과 @DisabledOnOS ex) @EnabledOnOS({OS.LINUX, OS.MAC})
9. 실행 시점이 다르다고 실패하지 않기
   - 시간을 명시적으로 제어할 수 있는 방법을 선택하는 것이 좋음
     - 시간을 파람으로 전달받아 비교하거나
     - 별도의 시간 클래스를 작성하거나
10. 랜덤하게 실패하지 않기
    - 직접 랜덤값을 생성하지 말고 생성자를 통해 값을 받도록 수정
    - 랜덤값 생성을 다른 객체에게 위임한거나 use 대역
11. 필요하지 않은 값은 생성하지 않기
    - 테스트에 필요한 값만 설정하면 필요하지 않은 값을 설정하느라 고민할 필요가 없다.
    - 그렇게 하면 테스트 코드가 짧아져서 한눈에 내용을 파악할 수 있다. 
12. 단위 테스트를 위한 객체 생성 보조 클래스
    - 상황구성을 위해 필요한 데이터가 복잡할 때가 있음 -> 테스트를 위한 객체 생성 클래스를 따로 만들면 복잡함 줄임
13. 조건부로 검증하지 않기
    - 테스트는 성공하거나 실패해야한다.
    - 성공하거나 실패하려면 반드시 단언 실행
    - 단언 하지 않으면 그 테스트는 실패도 성공도 아님
    - 조건을 넣을거면 조건에 대한 단언도 추가해야한다.
14. 통합테스트는 필요하지 않은 범위까지 연동하지 않기
    - ex) @JdbcTestaus면 충분한 테스트 코드를 @SpringBootTest를 하지 말아라 
15. 더이상 쓸모 엄는 테스트 코드
    - 익숙하지 않은 기능을 익히려고 만든 테스트 코드 익힌 후 삭제
    - 단순히 테스트 커버리지를 높이기 위한 목적으로 작성한 테스트코드 유지 필요 없음 삭제 


- 테스트 커버리지
  - 테스트 하는 동안 실행하는 코드가 얼마나 되는지 설명하기 위해 사용하는 지표 (보통 비율 사용)
  - ex) 단순하게 10줄 메서드를 수행하는데 테스트하는 동안 8줄 코드 실행 -> 테스트 커버리지 80%
  - 높여야 한다면 실제로 테스트 코드가 다루지 않는 if-else나 하위 타입등을 찾아 테스트를 추가하라
  - 그리고 보통은 커버리지 구하는건 복잡하다. (if-else, 하위 타입, 반복문 등 존재 탓)


### 11. 마치며 

- 테스트 코드는 회귀 테스트로 사용할 수 있다.
  - 회귀 테스트 : 개발하고 테스트한 소프트웨어가 이후에 코드를 수정해도 기존 코드가 올바르게 동작하는지 확인하기 위한 테스트
- 코드 수정이나 새로 추가 시 앞서 작성한 테스트 코드를 사용하면 다른 기능에 문제가 없는지 바로 확인할 수 있다.
- 레거시에 대한 테스트 추가
  - 일부 코드를 리팩토링해서 테스트 코드를 만들 수 있는 구조로 변경
  - 테스트 코드를 만들고 싶은 코드를 별도 클래스로 분리하는 방법 많이 사용
  - 그 뒤에 분리한 코드의 테스트 코드 작성 (분리 코드 범위가 작을 수록 테스트 만들기 쉬움)
- 전체 개발 시간을 줄이려면 코딩 시간 뿐 아니라 테스트, 디버깅 시간까지 줄여야한다.
- 테스트 수동 진행 시 개발 진행할수록 테스트 시간은 길어짐. 기능 많아지고 복잡해지니
- -> 테스트 자동화가 필요 
- 연습 많이하세용~~



  