## TDD 공부 Repository

테스트 주도 개발 시작하기 책으로 TDD 수터디중
관련 내용 정리 진행

### 준비 
TDD를 위한 다양한 도구가 존재하는데 자바에서는 주로 Junit을 사용한다. (Junit5)
pom파일에 junit 의존성 추가
```
...
<!-- junit-jupiter 의존을 test 범위로 추가한다. -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.5.0</version>
    <scope>test</scope>
</dependency>
...
<!-- 2.22.0부터 junit5지원 -->
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.1</version>
</plugin>
...
```

### TDD란?
- 테스트 부터 시작. 그 다음에 구현
- 테스트를 먼저한다 = 기능이 올바르게 동작하는지 검증하는 테스트 코드를 작성한다는 것을 의미
- 이 테스트를 통과 시키기 위해 개발을 진행한다.

-> 테스트를 먼저 작성하고 테스트에 실패하면 테스트를 통과 시킬만큼 코드를 추가하는 과정을 반복하면서 점진적으로 기능을 완성해 나감


**테스트 작성** 
- 첫번째 테스트를 선택할 때에는 가장 쉽거나 가장 예외적인 상황을 선택해야함
- 테스트 -> 코딩 -> 리펙토링 -> 테스트 반복.. (레드-그린-리펙터)
- TDD는 기능을 검증하는 테스트를 먼저 작성. 통과 못하면 통과 만큼만 코드 작성. 테스트 통과 뒤 리펙토링 반복 기능완성


&nbsp;
----
### 테스트 코드 작성 순서

- 쉬운 경우에서 어려운 경우로 진행 (복잡한거부터 하지마세요)
- 예외적인 경우에서 정상인 경우로 진행 

**구현하기 쉬운 테스트부터 시작하기**
- 가장 구현하기 쉬운 경우부터 시작하면 빠르게 통과시킬 수 있다.
    - 보통 수분에서 십여 분 이내에 구현을 완료해서 통과시킬 수 있을 만큼 쉬운 것 선택
    - 두가지 모두 그냥 해당 값을 리턴
        - 모든 조건을 충족하는 경우
        - 모든 조건을 충족하지 않는 경우

**예외 상황 먼저 테스트해야하는 이유**
- 중간 예외 처리 시 조건문 중복 추가 -> 코드 복잡 버그 가능성 높임
- 초반 예외 테스트 시 이런 가능성 줄어들음

&nbsp;

### 구현 단계
1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화


**조언**
- 당연한 말이지만 구현을 시도했는데 잘 안되면 한발 물러서서 다시하세요
- 테스트를 통과한 뒤에는 리팩토링을 진행하세요
- 일단 동작하는 코드를 만드는 능력이 중요합니다.
- TDD 시작할 때 테스트할 목록을 미리 정리하면 좋다.
- 테스트 과정에서 새로운 테스트 사례 발견 시 그 사례를 목록에 추가 
- 테스트 목록을 적었다고 테스트를 한번에 다 작성하면 안됨
  - 하나의 테스트 코드를 만들고 이를 통과시키고 리펙토링하고 다음 테스트 코드 통과 리펙토링하는 짧은 리듬 반복
- 범위가 큰 리팩토링 진행 하기 전에는 코드 커밋 잊지 마세요
- 시작이 안될때는 단언부터 고민하세요
  - assertEquals(기대일, 만료일);
- TDD 진행 시 어떻게 해야할 지 생각이 나지 않거나 잘못한거 같을 떄 과감하게 코드를 지우고 다시 시작하세요
  - 명싱 쉬운테스트부터, 예외테스트부터, 완급조절

&nbsp;


### 04. 기능 명세 설계
- 설계는 기능 명세로부터 시작한다.
- 기능 명세를 구체화 하는 동안 입력과 결과를 도출하고 이렇게 도출한 기능 명세를 코드에 반영한다.
- 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파람, 리턴 타입등이 결정된다. 
- -> 이런 과정이 곧 설계

- 테스트 만드려면 ? 
  - 테스트할 기능 실행
    - 클래스, 메서드, 함수이름
    - 파라미터
  - 결과를 검증
    - 리턴 값

- 모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영
  - -> 테스트코드는 예를 이용한 구체적인 명세가 됨
- 최대한 예외적, 복잡한 상황에 해당하는 구체적인 예르 끄집어내야함
  - 담당자와 대화! (하지않는다면 원하는 결과를 얻을 수 없을 것)


### 05. Junit5 기초
- assertEquals() 메서드
  - 첫번째인자 : 기대값 / 두번째인자 : 검사하려는 값

#### 테스트 라이프 사이클
- Junit은 각 테스트마다 다음 순서로 코드 실행
1. 테스트 메서드를 포함한 객체 생성
2. (존재시) @BeforeEach 애너테이션 붙은 메서드 실행
   - @BeforeEach //private이면 안됨. 테스트 실행하는데 필요한 준비 작업시 사용
3. @Test 애너테이션 붙은 메서드 실행
4. (존재시) @AfterEach 애너테이션 붙은 메서드 실행
  - private이면 안됨. 테스트 실행 후 정리한 것이 있을 때 사용

- @BeforeAll
  - 한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야할 때
  - 정적 메서드에 붙임
- @AfterAll
  - 클래스의 모든 테스트 메서드를 실행한 뒤에 실행
  - 정적 메서드에 적용

#### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기
- 각 테스트 메서드는 서로 독립적으로 동작해야함
- 한 테스트의 메서드의 결과에 따라 다른 테스트의 메서드의 실행 결과가 달라지면 안됨
- 테스트 메서드가 서로 필드를 공유한다거나 실행 순서를 가정하고 테스트 하지 말 것

- @DisplayName
- @Disabled
  - 특정 테스트를 실행하고 싶지 않을 때
  - 아직 테스트 코드가 완성되지 않았거나 잠시동안 테스트를 실행하지 말아야할 때 사용

  
#### 모든 테스트 실행하기
- 개발 과정에서는 특정 테스트 클래스나 메서드만 실행
- 운영 배포 전에 모든 테스트 실행해서 깨지는게 없는지 확인
  - mvn test (래퍼 사용시 mvnw test)
  - gradle test (래퍼 사용시 gradlew test)
- maven life cycle에선 package에서도 실행


### 6. 테스트 코드의 구성
- 상황 찾기
  - 다양한 예외 상황을 찾아내고 이를 코드에 반영해야 기능이 비정상적으로 동작하는 것을 막을 수 있다.
- 테스트 코드의 구성요소
  - 상황(given)
  - 실행(when)
  - 결과(then)
- 실행 결과를 확인하는 쉬운 방법 : 리턴 값을 사용
- 상황이 테스트 대상으로 국한된 것은 아님. 외부 요인도 잇음
- 테스트 코드 안에 필요한 것이 다있음 장점
  - 테스트 내용을 이해하기 위해 많은 파일을 볼 필요가 없다.
- 테스트 대상이 아닌 외부에서 확인이 필요할 때도 있다.
  - 처리 결과 지정 경로 파일 생성 기능
  - -> 실행 결과 검증하려면 해당 경로에 파일이 원하는 대로 만들어졌는지 확인 
- 외부 상태가 테스트 결과에 영향을 주지 않게 하기 
  - 테스트 코드는 한번만 실행하고 끝이 아님. 계속 지속 반복 테스트 문제 없는지 검증
  - -> 언제 실행해도 항상 정상 동작이 중요
  - 테스트 실행전에 외부를 원하는 상태로 만들거나 테스트 실행 후 외부 상태를 원래대로 돌려놓아야한다. ex)롤백
- 테스트는 모든 상황이 고려되어야함
  - ex) 금융 회사에서 제공하는 REST API 사용시 자동이체 등록 기능에 대한 테스트 
    1. REST API 응답 결과가 유효한 계좌 번호인 상황
    2. 유효하지 않은 계좌 번호인 상황
    3. 서버에 연결할 수 없는 상황
    4. 서버에서 응답을 5초 이내에 받지 못하는 상황
- -> 테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재.
- 테스트 대상의 상황과 결과에 외부 요인이 관여하는 경우 대역을 사용하면 테스트가 쉬워짐
  - 대역 : 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현. 이를 통해 외부 상황, 결과 대체 가능

