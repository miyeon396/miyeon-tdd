## TDD 공부 Repository

테스트 주도 개발 시작하기 책으로 TDD 수터디중
관련 내용 정리 진행

### 준비 
TDD를 위한 다양한 도구가 존재하는데 자바에서는 주로 Junit을 사용한다. (Junit5)
pom파일에 junit 의존성 추가
```
...
<!-- junit-jupiter 의존을 test 범위로 추가한다. -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.5.0</version>
    <scope>test</scope>
</dependency>
...
<!-- 2.22.0부터 junit5지원 -->
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.1</version>
</plugin>
...
```

### TDD란?
- 테스트 부터 시작. 그 다음에 구현
- 테스트를 먼저한다 = 기능이 올바르게 동작하는지 검증하는 테스트 코드를 작성한다는 것을 의미
- 이 테스트를 통과 시키기 위해 개발을 진행한다.

-> 테스트를 먼저 작성하고 테스트에 실패하면 테스트를 통과 시킬만큼 코드를 추가하는 과정을 반복하면서 점진적으로 기능을 완성해 나감


**테스트 작성** 
- 첫번째 테스트를 선택할 때에는 가장 쉽거나 가장 예외적인 상황을 선택해야함
- 테스트 -> 코딩 -> 리펙토링 -> 테스트 반복.. (레드-그린-리펙터)
- TDD는 기능을 검증하는 테스트를 먼저 작성. 통과 못하면 통과 만큼만 코드 작성. 테스트 통과 뒤 리펙토링 반복 기능완성


&nbsp;
----
### 테스트 코드 작성 순서

- 쉬운 경우에서 어려운 경우로 진행 (복잡한거부터 하지마세요)
- 예외적인 경우에서 정상인 경우로 진행 

**구현하기 쉬운 테스트부터 시작하기**
- 가장 구현하기 쉬운 경우부터 시작하면 빠르게 통과시킬 수 있다.
    - 보통 수분에서 십여 분 이내에 구현을 완료해서 통과시킬 수 있을 만큼 쉬운 것 선택
    - 두가지 모두 그냥 해당 값을 리턴
        - 모든 조건을 충족하는 경우
        - 모든 조건을 충족하지 않는 경우

**예외 상황 먼저 테스트해야하는 이유**
- 중간 예외 처리 시 조건문 중복 추가 -> 코드 복잡 버그 가능성 높임
- 초반 예외 테스트 시 이런 가능성 줄어들음

&nbsp;

### 구현 단계
1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화


**조언**
- 당연한 말이지만 구현을 시도했는데 잘 안되면 한발 물러서서 다시하세요
- 테스트를 통과한 뒤에는 리팩토링을 진행하세요
- 일단 동작하는 코드를 만드는 능력이 중요합니다.
- TDD 시작할 때 테스트할 목록을 미리 정리하면 좋다.
- 테스트 과정에서 새로운 테스트 사례 발견 시 그 사례를 목록에 추가 
- 테스트 목록을 적었다고 테스트를 한번에 다 작성하면 안됨
  - 하나의 테스트 코드를 만들고 이를 통과시키고 리펙토링하고 다음 테스트 코드 통과 리펙토링하는 짧은 리듬 반복
- 범위가 큰 리팩토링 진행 하기 전에는 코드 커밋 잊지 마세요
- 시작이 안될때는 단언부터 고민하세요
  - assertEquals(기대일, 만료일);
- TDD 진행 시 어떻게 해야할 지 생각이 나지 않거나 잘못한거 같을 떄 과감하게 코드를 지우고 다시 시작하세요
  - 명싱 쉬운테스트부터, 예외테스트부터, 완급조절

&nbsp;


### 04. 기능 명세 설계
- 설계는 기능 명세로부터 시작한다.
- 기능 명세를 구체화 하는 동안 입력과 결과를 도출하고 이렇게 도출한 기능 명세를 코드에 반영한다.
- 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파람, 리턴 타입등이 결정된다. 
- -> 이런 과정이 곧 설계

- 테스트 만드려면 ? 
  - 테스트할 기능 실행
    - 클래스, 메서드, 함수이름
    - 파라미터
  - 결과를 검증
    - 리턴 값

- 모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영
  - -> 테스트코드는 예를 이용한 구체적인 명세가 됨
- 최대한 예외적, 복잡한 상황에 해당하는 구체적인 예르 끄집어내야함
  - 담당자와 대화! (하지않는다면 원하는 결과를 얻을 수 없을 것)


### 05. Junit5 기초
- assertEquals() 메서드
  - 첫번째인자 : 기대값 / 두번째인자 : 검사하려는 값

#### 테스트 라이프 사이클
- Junit은 각 테스트마다 다음 순서로 코드 실행
1. 테스트 메서드를 포함한 객체 생성
2. (존재시) @BeforeEach 애너테이션 붙은 메서드 실행
   - @BeforeEach //private이면 안됨. 테스트 실행하는데 필요한 준비 작업시 사용
3. @Test 애너테이션 붙은 메서드 실행
4. (존재시) @AfterEach 애너테이션 붙은 메서드 실행
  - private이면 안됨. 테스트 실행 후 정리한 것이 있을 때 사용

- @BeforeAll
  - 한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야할 때
  - 정적 메서드에 붙임
- @AfterAll
  - 클래스의 모든 테스트 메서드를 실행한 뒤에 실행
  - 정적 메서드에 적용

#### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기
- 각 테스트 메서드는 서로 독립적으로 동작해야함
- 한 테스트의 메서드의 결과에 따라 다른 테스트의 메서드의 실행 결과가 달라지면 안됨
- 테스트 메서드가 서로 필드를 공유한다거나 실행 순서를 가정하고 테스트 하지 말 것

- @DisplayName
- @Disabled
  - 특정 테스트를 실행하고 싶지 않을 때
  - 아직 테스트 코드가 완성되지 않았거나 잠시동안 테스트를 실행하지 말아야할 때 사용

  
#### 모든 테스트 실행하기
- 개발 과정에서는 특정 테스트 클래스나 메서드만 실행
- 운영 배포 전에 모든 테스트 실행해서 깨지는게 없는지 확인
  - mvn test (래퍼 사용시 mvnw test)
  - gradle test (래퍼 사용시 gradlew test)
- maven life cycle에선 package에서도 실행


### 6. 테스트 코드의 구성
- 상황 찾기
  - 다양한 예외 상황을 찾아내고 이를 코드에 반영해야 기능이 비정상적으로 동작하는 것을 막을 수 있다.
- 테스트 코드의 구성요소
  - 상황(given)
  - 실행(when)
  - 결과(then)
- 실행 결과를 확인하는 쉬운 방법 : 리턴 값을 사용
- 상황이 테스트 대상으로 국한된 것은 아님. 외부 요인도 잇음
- 테스트 코드 안에 필요한 것이 다있음 장점
  - 테스트 내용을 이해하기 위해 많은 파일을 볼 필요가 없다.
- 테스트 대상이 아닌 외부에서 확인이 필요할 때도 있다.
  - 처리 결과 지정 경로 파일 생성 기능
  - -> 실행 결과 검증하려면 해당 경로에 파일이 원하는 대로 만들어졌는지 확인 
- 외부 상태가 테스트 결과에 영향을 주지 않게 하기 
  - 테스트 코드는 한번만 실행하고 끝이 아님. 계속 지속 반복 테스트 문제 없는지 검증
  - -> 언제 실행해도 항상 정상 동작이 중요
  - 테스트 실행전에 외부를 원하는 상태로 만들거나 테스트 실행 후 외부 상태를 원래대로 돌려놓아야한다. ex)롤백
- 테스트는 모든 상황이 고려되어야함
  - ex) 금융 회사에서 제공하는 REST API 사용시 자동이체 등록 기능에 대한 테스트 
    1. REST API 응답 결과가 유효한 계좌 번호인 상황
    2. 유효하지 않은 계좌 번호인 상황
    3. 서버에 연결할 수 없는 상황
    4. 서버에서 응답을 5초 이내에 받지 못하는 상황
- -> 테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재.
- 테스트 대상의 상황과 결과에 외부 요인이 관여하는 경우 대역을 사용하면 테스트가 쉬워짐
  - 대역 : 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현. 이를 통해 외부 상황, 결과 대체 가능


### 7. 대역 
- 테스트 진행 시 외부 요인이 필요한 시점
  - 테스트 대상에서 파일 시스템을 사용
  - DB로부터 데이터를 조회하거나 데이터를 추가
  - 테스트 대상에서 외부의 HTTP 서버와 통신 

- 테스트 대상에서 의존하는 요인 때문에 테스트가 어려울 때는 대역을 써서 테스트를 진행
- **대역의 종류**  ****
  - 스텁(Stub)
    - 구현을 단순한 것으로 대체한다.
    - 테스트에 맞게 단순히 원하는 동작을 수행한다.
    - ex) StubCardNumberValidator가 스텁 대역에 해당
  - 가짜(Fake)
    - 제품에는 적합하지 않지만 실제 동작하는 구현을 제공한다.
    - DB 대신에 메모리를 이용해서 구현하는 등
    - ex) MemoryAutoDebitInfoRepository가 가짜 대역에 해당
  - 스파이(Spy)
    - 호출된 내역을 기록한다.
    - 기록한 내용은 테스트 결과를 검증할 떄 사용한다.
    - 스텁이기도 하다.
  - 모의 객체(Mock)
    - 기대한 대로 상호작용 하는지 행위를 검증
    - 기대한 대로 동작하지 않으면 익셉션을 발생할 수 있다.
    - 모의객체는 스텁이자 스파이일 수도 있다.
- 구현하기 전에 모든 기능을 설계 불가능 -> 개발진행시 요구사항 계쏙 바뀔수도 있어서

#### 상황과 결과 확인을 위한 협업 대상(의존) 도출과 대역 사용
- 한 테스트는 특정한 상황에서 기능을 실행하고 그 결과를 확인
- 실제 구현을 이용하면 상황을 만들기 어려울 때가 많음
- 제어가 힘든 외부 상황 존재시 다음 방법으로 의존 도출 및 대역으로 이용
  - 제어하기 힘든 외부 상황을 별도 타입으로 분리 ex) StubCardValidator
  - 테스트 코드는 별도로 분리한 타입의 대역을 생성
  - 생성한 대역을 테스트 대상의 생성자 등을 이용해서 전달
  - 대역을 이용해서 상황 구성
- 당장 구현하는데 시간이 오래 걸리는 로직도 분리하기에 좋은 후보.

#### 대역과 개발 속도
- 대역은 의존하는 대상을 구현하지 않아도 테스트 대상을 완성할 수 있게 만들어 주고 대기시간 줄여줘 개발 속도 올림
  - 대역 사용시 실제 구현 없어도 다양한 상황에서 테스트 가능
  - 대역을 사용하면 실제 구현이 없어도 실행 결과 확인 가능

#### 모의 객체를 과하게 사용하지 않기!
- 모의 객체는 스텁과 스파이를 지원하므로 대역으로 모의객체 많이 사용
- 하지만 모의객체 과하게 사용하면 오히려 테스트 코드가 복잡해지는 경우도 있음.
- dao나 리포지토리 같이 저장소에 대한 대역은 모의 객체를 사용하는 것 보다 메모리를 이용한 가짜 구현을 사용하는 것이 테스트 코드 관리에 유리하다.
  - 첨엔 더 걸릴 수 있으나 일단 가짜 대역을 구현하면 모의객체를 사용할때 보다 테스트 코드 간결 관리 쉬움


---

### 부록C. Mockito 기초 사용법
- Mockito : 모의 객체 생성, 검증, 스텁을 지원하는 fw
- 사용하려면 mokcito-core 모듈 추가

#### 모의 객체 생성
- Mocito.mock()

#### 스텁 설정
- 모의객체를 생성한 뒤에 BDDMockito 클래스를 이용해서 모의 객체에 스텁을 구성할 수 있다.
- BDDMockito.given() 메서드 이용
  - 스텁을 정의할 모의객체의 메서드 호출을 전달
- given()에 이어 willReturn() 메서드는 스텁을 정의한 메서드가 리턴할 값을 지정
- ex)
  - (1) 모의 객체 생성 : GameNumGen genMock = mock(GameNumGen.class)
  - (2) 스텁 설정 : given(genMock.generate(GameLevel.EASY)).willReturn("123");
  - (3) 스텁 설정에 매칭되는 메서드 실행 : String num = genMock.generate(GameLevel.EASY)
- 지정한 값 리턴하는 대신 익셉션 발생하게 설정 willTrhow(IllegalArgumentException.class)

#### 인자 매칭 처리
- Mockito는 일치하는 스텁 설정이 없을 경우 리턴 타입의 기본 값을 리턴한다.
  - ex) int 0, boolean false 기본 데이터 타입이 아닌 String/List와 같은 참조 타입이면 null
- Mockito.ArgumentMatchers클래스 사용시 정확하게 일치하는값 대신 임의의 값 일치하도록 설정 가능
  - any(), anyInt, anyShort(), anyLong, ... anyList, any(), matches(String), matches(Pattern), eq(값)
- 스텁을 설정할 메서드의 인자가 두개 이상인 경우 주의
- 임의의 값과 일치하는 인자와 정확하게 일치하는 인자를 함께 사용하고 싶다면 ArgumentMatchers.eq()


#### 행위 검증
- 모의 객체의 역할 중 하나는 실제로 모의 객체가 불렸는지 검증하는 것
- BDDMockito.then() : 메서드 호출 여부를 검증할 모의 객체를 전달 받는다.
- should() : 모의 객체의 메서드가 불려야 한다는 것을 설정하고 뒤에 실제 불려야할 메서드 지정
- ex) then(genMock).should().generate(GameLevel.EASY);
- 정확한 값이 아닌 메서드가 불렸는지 여부가 중요하면 any, anyInt...
  - ex) then(genMock).should().generate(any());
- 정확하게 한번만 호출된 것 검증
  - ex) then(genMock).should(only()).generate(any());
- 메서드 호출 횟수 검증 위해 Mockito 클래스가 제공하는 메서드
  - only() : 한번만 호출
  - times(int) : 지정 횟수만큼 호출
  - never() : 호출x
  - atLeast(int) : 적어도 지정한 횟수만큼
  - atLeatOnce : atLeast(1)
  - atMost(int) : 최대 지정한 횟수만큼

#### 인자 캡처
  - 모의 객체 호출 할 때 사용한 인자 검증 해야할 떄 있음
  - Mockito의 ArgumentCaptor : 메서드 호출 여부를 검증하는 과정에서 실제 호출할 때 전달한 인자 보관
    ```
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class)
    then(mockEmailNotifiler).sholud().sendRegisterEmail(captor.capture());
    String relEmail = captor.getValue();
    assertEquals("email@email.com", realEmail);
    ```

#### Junit5 확장 설정
- Mockito의 Junit5 확장 기능을 사용하면 애노테이션을 이용해서 모의 객체 생성 가능
- mockito-junit-jupitor -> Mocito Extension 사용 가능
- @Mock : 붙인 필드에 대해 자동으로 모의 객체 생성해줌
  ```
  @ExtendWith(MocktoExtension.class)
  public class Junit5ExtensionTest() {
  @Mock
  private GameNumGen genMock;
  ```